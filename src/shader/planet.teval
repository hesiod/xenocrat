#version 450 core

#insert noise3D

layout(triangles, equal_spacing, cw) in;
in vec3 tctrl_position[];
out vec3 teval_position;
out vec3 teval_normal;
uniform mat4 proj;
uniform mat4 model;
uniform mat4 view;
uniform float zoom;
uniform vec3 origin;

vec3 to_polar(const vec3 c)
{
  float r = length(c);
  float theta = acos(c.z / r);
  float phi = atan(c.y, c.x + 1e-19);
  return vec3(r, theta, phi);
}

vec3 to_cartesian(const vec3 p)
{
  return vec3(p.x * sin(p.y) * cos(p.z),
	      p.x * sin(p.y) * sin(p.z),
	      p.x * cos(p.y));
}

float fBm(const vec3 v, out vec3 normal, const float radius, const int octaves, float frequency, const float gain, const float lacunarity)
{
  float rv = 0.0;
  normal = vec3(0,0,0);
  float amplitude = gain;

  for (int i = 0; i < octaves; ++i)
  {
      vec3 grad;
      vec3 x = v * frequency;
      float factor = snoise(x, grad) * amplitude;
      rv += factor;
      normal += grad * amplitude;
      frequency *= lacunarity;
      amplitude *= gain;
  }
  return rv;
}

void main()
{
  vec3 p = normalize(gl_TessCoord.x * tctrl_position[0] +
		     gl_TessCoord.y * tctrl_position[1] +
		     gl_TessCoord.z * tctrl_position[2]);
  vec3 po = to_polar(p) - origin;
  float s = 0.2;
  po.x += fBm(p, teval_normal, po.x, 16, 0.35, 0.6, 1.8715) * s;
  //po.x += snoise(p, teval_normal) * s;
  teval_normal /= po.x;
  mat3 normalM = mat3(transpose(inverse(proj * view * model)));
  teval_normal = normalize(normalM * (p - s * (teval_normal - dot(teval_normal, p) * p)));
  vec3 noisy = to_cartesian(po) + origin;
  gl_Position = proj * view * model * vec4(noisy / zoom, 1);
  teval_position = vec3(gl_Position);
}
